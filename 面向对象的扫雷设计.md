<h1 align="center">面向对象的扫雷游戏设计</h1>

## 1. 项目概述

本项目采用**C++面向对象**设计方法实现经典扫雷游戏，旨在展示面向对象与面向过程程序设计的本质区别，深入**理解面向对象程序的分层架构与组件化设计思想**。通过合理划分职责边界，实现高内聚、低耦合的模块化设计。

## 2. 游戏参考与设计目标

本项目参考经典扫雷游戏的界面与功能，目标是复刻如下网页版扫雷游戏的核心体验：

**[扫雷游戏网页版 - Minesweeper](https://www.minesweeper.cn/)**

![扫雷游戏效果图](https://gitee.com/sheepdestorage/repository/raw/master/images/20250514170309827.png)

## 3. 系统架构设计

### 3.1 界面布局分析

通过对经典扫雷游戏界面的分析，我们将系统划分为以下主要组件：

![布局分析](https://gitee.com/sheepdestorage/repository/raw/master/images/20250514170307291.png)

1. **信息栏区域**：包含计时器、笑脸按钮和雷数计数器
2. **雷区**：主游戏区域，包含可点击的格子矩阵
3. **状态显示**：游戏状态反馈（进行中/胜利/失败）

### 3.2 三层架构设计

基于面向对象的设计原则，我们采用三层架构模式：

![文件结构](https://gitee.com/sheepdestorage/repository/raw/master/images/20250514170303418.png)

#### 3.2.1 顶层控制层 (Game)

**Game.cpp/Game.h**: 作为系统控制中心，负责整体游戏流程管理和协调各组件

主要职责：
1. **游戏初始化与控制**：创建游戏窗口、设置游戏参数、管理整体游戏状态
2. **窗口与界面管理**：控制窗口尺寸、位置和样式，处理窗口事件
3. **信息栏组件管理**：
   - 雷数计数器的显示与更新
   - 笑脸按钮的状态管理与重置功能
   - 计时器的初始化、启动和显示
4. **用户输入处理**：捕获鼠标点击事件，确定点击位置与类型（左/右键）
5. **游戏状态管理**：处理游戏结束逻辑，判定胜利/失败条件
6. **难度设置**：（可选）提供不同难度级别的游戏配置

#### 3.2.2 中层管理层 (Board)

**Board.cpp/Board.h**: 负责雷区数据管理与操作

主要职责：
1. **雷区初始化**：创建格子矩阵，负责首次点击时安全地放置地雷
2. **雷数统计**：计算每个格子周围的地雷数
3. **点击事件处理**：接收来自Game层的点击事件，转换为具体的格子操作
4. **连续空白区域揭开**：实现自动揭开相连的空白区域算法
5. **游戏状态检测**：检测踩雷或完成所有非雷格子的情况，通过回调通知Game层
6. **雷数计数管理**：跟踪剩余未标记雷数，提供接口给顶层获取

#### 3.2.3 底层实体层 (Grid)

**Grid.cpp/Grid.h**: 管理单个格子的状态与显示

主要职责：
1. **格子状态管理**：维护格子的核心属性（是否有雷、周围雷数、当前显示状态）
2. **状态转换**：处理格子的打开、标记等状态变化
3. **显示逻辑**：根据当前状态显示对应的图像
4. **资源管理**：加载和维护格子相关的图像资源

#### 3.2.4 入口模块 (StartGame)

**StartGame.cpp**: 提供程序入口点

主要职责：
1. 创建Game类实例
2. 初始化游戏环境
3. 启动游戏主循环

## 4. 核心功能设计

### 4.1 格子操作机制

格子可能处于以下几种状态，需要针对不同状态设计相应的交互行为：

![雷的情况](https://gitee.com/sheepdestorage/repository/raw/master/images/20250514170255935.png)

#### 操作流程：

1. **左键点击未打开格子**：
   ```
   Grid::open()
     ↓
   检查是否有地雷
     ↓ (是)
   通知Board层 → 触发回调 → 游戏结束(失败)
     ↓ (否)
   显示数字 → 检查是否为0 → 是则触发连续揭开
   ```

2. **右键点击未打开格子**：
   ```
   Grid::toggleFlag()
     ↓
   切换标记状态
     ↓
   Board::updateRemainingMines() → 更新剩余雷数
   ```

3. **左键或右键点击已标记格子**：
   ```
   Grid::toggleFlag()
     ↓
   取消标记
     ↓
   Board::updateRemainingMines() → 更新剩余雷数
   ```

### 4.2 周围雷数计算

![周围雷的数量](https://gitee.com/sheepdestorage/repository/raw/master/images/20250514170243351.png)

遵循**职责分配均衡原则**，我们在Board层实现此功能：

```
Board::countMines()
  ↓
遍历每个格子
  ↓
检查8个方向的相邻格子
  ↓
计算周围地雷数量
  ↓
Grid::setAdjacentMines() → 设置格子的周围雷数属性
```

### 4.3 连续空白区域揭开算法

为实现点击空白格子时连续揭开相连区域的功能，我们可以选择以下两种算法之一：

#### 4.3.1 深度优先搜索 (DFS)

```
Board::openAdjacentCells(row, col)
  ↓
遍历8个方向
  ↓
对每个未打开且未标记的相邻格子
  ↓
递归调用openCell(ni, nj)
  ↓
递归终止条件：
1. 遇到边界 2. 已打开格子 3. 已标记格子 4. 数字格子
```

**优点**：
- 实现简单直观，代码结构清晰
- 自然符合递归思想，逻辑易于理解
- 适合中小规模雷区

**缺点**：
- 对于大型雷区可能导致栈溢出风险
- 在极端情况下性能可能不如BFS

#### 4.3.2 广度优先搜索 (BFS)

```
使用队列记录待处理的格子
  ↓
将起始点加入队列
  ↓
循环处理队列中的格子
  ↓
对每个出队格子，检查其周围8个方向
  ↓
将未处理的空白格子加入队列
  ↓
直到队列为空
```

**优点**：
- 避免深层递归导致的栈溢出
- 对大型雷区表现更稳定
- 遵循逐层扩展的视觉效果

**缺点**：
- 实现相对复杂，需要维护额外的队列结构
- 代码逻辑不如DFS直观

根据**简单性原则**和游戏规模考虑，本项目采用DFS算法实现连续揭开功能，既保证代码清晰度，又满足性能需求。

### 4.4 点击事件传递链

用户交互通过严格的层级传递链完成，确保职责边界清晰：

```
Game::gameLoop() → 捕获系统鼠标事件
  ↓
Game::handleMouseClick(x, y, isLeftClick) → 确定点击区域
  ↓
若点击雷区：Board::handleMouseClick(x, y, isLeftClick)
  ↓
转换为格子坐标：row = (y - MARGIN) / CELL_SIZE
  ↓
调用相应操作：openCell(row, col) 或 toggleCellFlag(row, col)
  ↓
Grid对象状态更新 → 界面刷新
```

## 5. 面向对象设计原则应用

本项目实践了以下面向对象设计原则：

1. **单一职责原则 (SRP)**：每个类仅负责单一功能域，如Grid只关注单个格子的行为
  
2. **开放-封闭原则 (OCP)**：系统设计允许通过扩展而非修改来增加新功能
  
3. **接口隔离原则 (ISP)**：各层之间通过精心设计的接口通信，避免过度依赖
  
4. **依赖倒置原则 (DIP)**：高层模块不直接依赖低层实现细节，而是通过抽象接口交互
  
5. **组合优于继承**：通过组合关系构建系统，Game包含Board，Board包含Grid

系统通过明确的责任边界、清晰的数据流向和设计良好的接口实现了高内聚、低耦合的架构，使得代码更易于理解、维护和扩展。三层架构设计确保了每个组件专注于其核心职责，同时通过适当的回调机制和接口方法保持组件间的协调。

